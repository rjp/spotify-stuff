#! /usr/bin/env ruby

require 'rubygems'
require 'nokogiri'
require 'json'
require 'socket'
require 'uri'
require 'open-uri'

#
require 'despotlistback/options'
require 'despotlistback/convert'
require 'despotlistback/xspf'

# Ruby bindings for libdespotify - currently from http://github.com/rjp/despotify-ruby
require 'despotify'

# Rather than use [Mash][mash] and add another dependency, we fake methods by redirecting them to metadata lookups.
class Despotify::Track
    def method_missing method_name, *args, &block
        return self.metadata[method_name.to_s]
    end
end

# DespoGClient
class DespoGClient
    attr_accessor :username, :password, :host, :port
    attr_accessor :track_cache, :outputdir, :metacache, :metafile
    attr_accessor :socket, :playlists, :tracks

    def initialize(username, password, outputdir)
        @username = username
        @password = password
        @outputdir = outputdir

        # Create our (unauthenticated and useless) session to Spotify
        @session = Despotify::Session.new

        # Cache album metadata in memory to reduce the number of lookups we do.
        @metacache = {}

        @playlists = []
        @tracks = {}
        @track_cache = {}
    end

    def init_metacache
    end

    def album_metadata(aid)
        if not @metacache[aid].nil? then
            return @metacache[aid]
        end

        album = Despotify::AlbumBrowse.new(@session, aid)
        @metacache[aid] = album
        return album
    end

    # Authenticate ourselves to Spotify - this requires a premium account
    def login
        @session.authenticate(@username, @password)
    end

    def load_all_playlists
        $stderr.puts("L /pl/all")
        a = @session.stored_playlists
    end

    def load_playlists(playlist_ids)

        playlist_ids.each do |p|
            $stderr.puts("L /pl/#{p[0..33]}")
            pl = self.load_playlist(p[0..33])
            if not pl.nil? then
            $stderr.puts "=========***************=========="
                self.write_playlist(pl)
            end
        end
    end

    def load_playlist(pid)
        x = Despotify::Playlist.new(@session, pid[0..33])
        @playlists << x
        return x
    end

    def load_track(tid)
        if not @track_cache[tid].nil? then
            return @track_cache[tid]
        end

        if tid =~ /^spotify:local/ then
            # we can't look this track up remotely
            s, l, artist, album, title, duration = tid.split(/:/).map{|i| URI.unescape(i.gsub(/\+/,' '))}
            track = {:title => title, :artist => artist, :album => album, :tid => tid, :uri => tid, :duration => (1000*duration.to_i).to_s}
            @track_cache[tid] = track
            return track
        end

        if tid =~ /^spotify:track:(.*)/ then
            $stderr.puts "TU #{tid}"
        end

        # trim to 32 hex characters
        tid = tid[0..31]

        dom, junk = self.cmd("browsetrack", tid)

        track = {}
        success = dom.at("//total-tracks").inner_text.to_i

        if success > 0 then
            title = dom.at("//track/title").inner_text.strip
            artist = dom.at("//track/artist").inner_text.strip
            artist_id = dom.at("//track/artist-id").inner_text.strip
            album = dom.at("//track/album").inner_text.strip
            album_id = dom.at("//track/album-id").inner_text.strip
            index = dom.at("//track/track-number").inner_text.strip
            duration = dom.at("//track/length").inner_text.strip

            uri = id2uri(tid)
            if uri.nil? then
                $stderr.puts "!! #{tid} doesn't map to a URI somehow"
                uri = "_whoops_#{tid}_"
            end

            almeta = self.album_metadata(album_id)

            track = {:title => title, :artist => artist, :album => album, :tid => tid, :uri => uri, :index => index, :duration => duration, :aid => album_id, :album_meta => almeta, :arid => artist_id}

            eid = dom.at("//track/external-ids/external-id")
            if not eid.nil? and eid['type'] == 'isrc' then
                track[:isrc] = eid['id']
            end

            $stderr.puts track.inspect
            @track_cache[tid] = track
        end

        return track
    end
end

# xspf blindly passes unescaped strings to eval in single quotes. Because ... yes. Why not.
class String
  def sq
    self.gsub(/'/, "\\\\'")
  end
end

username, password = $options[:login].split(':', 2)

dsp = DespoGClient.new(username, password, $options[:output])
dsp.login()

# Has the user specified any playlists to load?
playlists = $options[:playlist].to_s.split(',')

# backward compatibility
playlists << ARGV

# We might have [[]] here which isn't what we want
playlists.flatten!

if playlists.size == 0 then
    dsp.load_all_playlists()
else
    dsp.load_playlists(playlists.flatten)
end
